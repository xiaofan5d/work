print('开始分仓,请稍后')
import pandas as pd
import numpy as np
import warnings 
warnings.filterwarnings("ignore")
#需要修改的参数
path_订单='9-28'
path_库存='9-28'
订单=pd.read_excel('C://Users//Administrator//Desktop//京东订单源数据//'+path_订单+'.xls')
库存_源数据=pd.read_excel('C://Users//Administrator//Desktop//茂浦库存//'+path_库存+'.xlsx')
标卡=pd.read_excel('C://Users//Administrator//Desktop//京东//标卡//曼秀雷敦全品类价单0518.xlsx',sheetname='SKU').fillna(0)
#要删除
标卡.公司货号=标卡.公司货号.astype(str)
库存_源数据=库存_源数据[(库存_源数据.货物状态=='NR')|(库存_源数据.货物状态=='OD')]
库存2=pd.merge(left=库存_源数据,right=标卡.loc[:,['公司货号','商品编码','条码','箱规','保质期','体积','重量']],left_on='商品代码',right_on='公司货号',how='left')
库存=库存2.pivot_table(index=['商品编码','条码','商品代码','商品名称','到期日期','箱规','保质期','体积','重量'],values=['可用数量'],aggfunc='sum').reset_index()
库存需要维护=库存[库存.商品编码==0]
库存=库存[(库存.可用数量!=0)&(库存.商品编码!=0)]
库存['散货数量']=库存.可用数量-(库存.可用数量/库存.箱规).astype(int)*库存.箱规
库存['可用数量']=库存.可用数量-库存.散货数量
库存拆分1=库存.drop('散货数量',axis=1)
库存拆分2=库存.drop('可用数量',axis=1).rename(columns={'散货数量':'可用数量'})
库存拆分1=库存拆分1[库存拆分1.可用数量!=0]
库存拆分1['箱柜属性']='整箱'
库存拆分2=库存拆分2[库存拆分2.可用数量!=0]
库存拆分2['箱柜属性']='散装'
库存拆分=[库存拆分1,库存拆分2]
库存=pd.concat(库存拆分)
#修改有效期格式
from datetime import datetime
from datetime import timedelta
import re
def 日期(value):
    m = re.search(r'(.*?) 上午 12:00:00',value)
    if m and m.group(1):
        return m.group(1)
库存.到期日期=库存.到期日期.map(日期)
库存.到期日期=pd.to_datetime(库存.到期日期)
库存.商品编码=库存.商品编码.astype(np.int)
##已经完成编码和条码的匹配以及聚合
#按照数量需要排序(升序)
库存处理=pd.DataFrame()
订单.商品编码=订单.商品编码.astype(str)
for i in 库存.商品编码.unique():
    库存1=库存[库存.商品编码==i]
    #需要修改
    库存1=库存1.sort_values(['箱柜属性','到期日期'],ascending=[False,True])
    库存1['辅助列']=np.arange(1,len(库存1)+1)
    库存处理=库存处理.append(库存1)
库存处理.辅助列=库存处理.辅助列.astype(int).astype(str)
库存处理.商品编码=库存处理.商品编码.astype(str)
库存处理['辅助列1']=库存处理.商品编码+库存处理.辅助列
x=库存处理.辅助列.astype(int).max()
y=pd.DataFrame()
for i3 in np.arange(1,x+1):
    订单[i3]=i3
    订单[i3]=订单[i3].astype(str)
    订单[i3]=订单['商品编码']+订单[i3]
z=1
while z<=x:
    订单=pd.merge(left=订单,right=库存处理.loc[:,['辅助列1','可用数量']],left_on=z,right_on='辅助列1',how='left').fillna(0)
    订单=订单.drop('辅助列1',axis=1)
    订单.可用数量=订单.可用数量.astype(int)
    订单=订单.rename(columns={'可用数量':x+z})
    z=z+1
库存修改箱柜=库存处理.pivot_table(index='商品编码',values='箱规',aggfunc='max').reset_index()
订单=pd.merge(left=订单,right=库存修改箱柜,left_on='商品编码',right_on='商品编码',how='left')
订单['采购数量1']=订单['采购数量']
订单['采购数量1']=(订单['采购数量1']/订单.箱规.fillna(0)).astype(int)*订单.箱规
订单=订单.drop('箱规',axis=1)
ix=1
订单处理h=pd.DataFrame()
while ix<=x:
    订单处理=pd.DataFrame()
    for i2 in 订单.商品编码.unique():
        订单1=订单[订单.商品编码==i2].sort_values('采购数量1')
        订单1['累加和']=订单1.采购数量1.cumsum()
        订单处理=订单处理.append(订单1)
    订单处理[x*2+ix]=订单处理[x+ix]-订单处理['累加和']
    订单处理.loc[订单处理[x*2+ix]>=0,x*3+1]=订单处理['采购数量1']
    订单处理.loc[(订单处理[x*2+ix]<0)&(订单处理.采购数量1+订单处理[x*2+ix]>0),x*3+1]=订单处理.采购数量1+订单处理[x*2+ix]
    订单处理.loc[(订单处理[x*2+ix]<0)&(订单处理.采购数量1+订单处理[x*2+ix]<=0),x*3+1]=0
    订单处理1=订单处理[订单处理[x*3+1]>0]
    订单处理1.loc[订单处理1[x*3+1]>0,'调拨条码']=订单处理1[ix]
    订单处理h=订单处理h.append(订单处理1)
    订单=订单处理[(订单处理[x*3+1]==0)|(订单处理[x*3+1]-订单处理.采购数量1<0)]
    订单.采购数量1=订单.采购数量1-订单[x*3+1]
    ix=ix+1
    if len(订单)==0:
        break
订单处理h=订单处理h.append(订单)
订单处理_最终=pd.merge(left=订单处理h,right=库存处理,left_on='调拨条码',right_on='辅助列1',how='left')
#修改为超过一箱为最低箱数,不满一箱为拆箱
订单处理_最终['箱数']=(订单处理_最终[x*3+1]/订单处理_最终.箱规).fillna(0)
#1
订单处理_最终.loc[订单处理_最终.箱数>1,'箱数']=订单处理_最终.箱数.astype(int)
订单处理_最终[x*3+1]=订单处理_最终.箱规*订单处理_最终.箱数
订单处理_最终=订单处理_最终.reindex(columns=['订单号','分配机构','仓库','详细地址','联系人','联系方式','商品编码_x','条码','商品名称_x','采购数量','采购金额','商品代码',x*3+1,'到期日期','箱规','箱数','保质期','体积','重量'])
订单处理_最终=订单处理_最终.rename(columns={'商品编码_x':'商品编码','商品名称_x':'商品名称',x*3+1:'仓库实发数量'})
订单处理_最终['体积']=订单处理_最终.体积*订单处理_最终.箱数
订单处理_最终['重量']=订单处理_最终.重量*订单处理_最终.箱数
订单处理_最终['货品总额']=订单处理_最终.采购金额/0.63/订单处理_最终.采购数量*0.56*订单处理_最终.仓库实发数量
订单处理_订单汇总=订单处理_最终.pivot_table(index=['订单号','分配机构','仓库','详细地址','联系方式'],values=['仓库实发数量','箱数','体积','货品总额','重量'],aggfunc='sum').reset_index()
订单处理_订单汇总['填开日期']=datetime.today().strftime('%Y-%m-%d')
订单处理_订单汇总['客户名称']='上海茂浦电子商务有限公司'
订单处理_订单汇总['始发地']='上海'
订单处理_订单汇总['电商名称']='京东商城'
订单处理_订单汇总=订单处理_订单汇总.reindex(columns=['填开日期','客户名称','始发地','分配机构','电商名称','订单号','仓库实发数量','箱数','货品总额','重量','体积','预约状态','预约日期','送货时间段','预约号','仓库','详细地址','联系方式','备注'])
订单处理_订单汇总=订单处理_订单汇总.sort_values(['分配机构','仓库','订单号'])
订单处理_发货明细=订单处理_最终.sort_values(['分配机构','仓库','订单号'])
订单处理_发货明细.loc[订单处理_发货明细.到期日期.notnull(),'有效期']=订单处理_发货明细.loc[订单处理_发货明细.到期日期.notnull(),'到期日期'].map(lambda x:x.strftime('%Y-%m-%d'))
订单处理_发货明细=订单处理_发货明细.drop('到期日期',axis=1)
订单处理_发货明细=订单处理_发货明细.reindex(columns=['订单号','分配机构','仓库','详细地址','联系人','联系方式','商品编码','条码','商品名称','采购数量','采购金额','商品代码','仓库实发数量','有效期','箱数','箱规','保质期','体积','重量'])
订单处理_发货明细.条码=订单处理_发货明细.条码.astype(str)
订单处理_发货明细=订单处理_发货明细.sort_values(['分配机构','仓库','订单号','商品编码'])
订单处理_发货明细=订单处理_发货明细.set_index(['订单号','分配机构','仓库','详细地址','联系人','联系方式','商品编码','商品名称','采购数量','采购金额','条码','商品代码'])
定义=订单处理_最终.保质期.fillna(0).map(lambda x:timedelta(x))
订单处理_最终['生产日期']=(订单处理_最终.到期日期-定义+定义/3).map(lambda x:x.date())
订单处理_最终.loc[订单处理_最终.生产日期<datetime.now().date()+timedelta(5),'是否超保']='超保'
导出路径=pd.ExcelWriter('C://Users//Administrator//Desktop//订单发仓库//出库明细@'+path_库存+'.xlsx')
订单处理_订单汇总.to_excel(导出路径,'订单汇总',index=None)                               
订单处理_发货明细.to_excel(导出路径,'发货明细')
订单处理_超保=订单处理_最终[(订单处理_最终.是否超保=='超保')&(订单处理_最终.仓库实发数量!=0)&(订单处理_最终.仓库实发数量.notnull())]
订单处理_超保['采销部门']='个护'
订单处理_超保明细=订单处理_超保.reindex(columns=['分配机构','仓库','采销部门','订单号','商品编码','商品名称','仓库实发数量','保质期','生产日期','到期日期']).sort_values(['订单号','分配机构','仓库'])
订单处理_超保明细['到期日期']=订单处理_超保明细.到期日期.map(lambda x:x.strftime('%Y-%m-%d'))
print('第二次分配完毕,正在正在进行导出,请稍后...')
订单处理_超保明细.to_excel(导出路径,'超保明细',index=None)
导出路径.save()
print('已完成并导出')
input('请美化下表格并按任意键退出')

